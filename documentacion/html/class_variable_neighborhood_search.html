<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Max-mean dispersion problem: VariableNeighborhoodSearch Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Max-mean dispersion problem
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_variable_neighborhood_search-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VariableNeighborhoodSearch Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Esta clase representa el algoritmo multiarranque.  
 <a href="class_variable_neighborhood_search.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="variable-neighborhood-search-algorithm_8hpp_source.html">variable-neighborhood-search-algorithm.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for VariableNeighborhoodSearch:</div>
<div class="dyncontent">
<div class="center"><img src="class_variable_neighborhood_search__inherit__graph.png" border="0" usemap="#_variable_neighborhood_search_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for VariableNeighborhoodSearch:</div>
<div class="dyncontent">
<div class="center"><img src="class_variable_neighborhood_search__coll__graph.png" border="0" usemap="#_variable_neighborhood_search_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c246a6b89a9eea5f3b17352f7cc7178"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#a7c246a6b89a9eea5f3b17352f7cc7178">VariableNeighborhoodSearch</a> (std::string newName, int newIterationsLimit, int noImprovementiterationsLimit, int newKmax)</td></tr>
<tr class="memdesc:a7c246a6b89a9eea5f3b17352f7cc7178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea el objeto y le asigna un nombre del algoritmo.  <a href="class_variable_neighborhood_search.html#a7c246a6b89a9eea5f3b17352f7cc7178">More...</a><br /></td></tr>
<tr class="separator:a7c246a6b89a9eea5f3b17352f7cc7178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa545a238609462a4e45120dbc7c10cde"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#aa545a238609462a4e45120dbc7c10cde">getAlgorithmName</a> ()</td></tr>
<tr class="memdesc:aa545a238609462a4e45120dbc7c10cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el nombre del algoritmo.  <a href="class_variable_neighborhood_search.html#aa545a238609462a4e45120dbc7c10cde">More...</a><br /></td></tr>
<tr class="separator:aa545a238609462a4e45120dbc7c10cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af731669d721090aec1cdb79c4f8da891"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#af731669d721090aec1cdb79c4f8da891">getIterationsLimit</a> ()</td></tr>
<tr class="memdesc:af731669d721090aec1cdb79c4f8da891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el límite de iteraciones.  <a href="class_variable_neighborhood_search.html#af731669d721090aec1cdb79c4f8da891">More...</a><br /></td></tr>
<tr class="separator:af731669d721090aec1cdb79c4f8da891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9260611826afa9fc98e533f4e14fcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#a2a9260611826afa9fc98e533f4e14fcd">getnoImprovementiterationsLimit</a> ()</td></tr>
<tr class="memdesc:a2a9260611826afa9fc98e533f4e14fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el número de iteracions sin mejora.  <a href="class_variable_neighborhood_search.html#a2a9260611826afa9fc98e533f4e14fcd">More...</a><br /></td></tr>
<tr class="separator:a2a9260611826afa9fc98e533f4e14fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6daf77e6bafdd0991a07ba116f2a788"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#aa6daf77e6bafdd0991a07ba116f2a788">getKmax</a> ()</td></tr>
<tr class="memdesc:aa6daf77e6bafdd0991a07ba116f2a788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devvuelve el tamaño del entorno máximo.  <a href="class_variable_neighborhood_search.html#aa6daf77e6bafdd0991a07ba116f2a788">More...</a><br /></td></tr>
<tr class="separator:aa6daf77e6bafdd0991a07ba116f2a788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9801bff3a36806d818d300010e0cd529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#a9801bff3a36806d818d300010e0cd529">run</a> (<a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:a9801bff3a36806d818d300010e0cd529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representa el método que va a realizar la ejecución del algorimo GVNS, para ello se va a partir de un conjunto de candidatos, que va a ser todo el conjunto de nodos. Una vez que tenemos esto, vamos a iterar hasta llegar a las iteraciones con o sin mejora, en cada una de ellas habrán iteraciones hasta que se llegue al tamaño de entorno máximo. En cada una de ellas se hará shake, luego se hará una búsqueda local y por último se buscará si la nueva solución tiene una dispersion media mejor que las anteriores y se asignará.  <a href="class_variable_neighborhood_search.html#a9801bff3a36806d818d300010e0cd529">More...</a><br /></td></tr>
<tr class="separator:a9801bff3a36806d818d300010e0cd529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f4646dcde00cb2efd2f41c34b40465"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#a05f4646dcde00cb2efd2f41c34b40465">shake</a> (std::vector&lt; int &gt; solution, int currentK, int newSolution)</td></tr>
<tr class="memdesc:a05f4646dcde00cb2efd2f41c34b40465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta es la función encargada de coger una solución aleatoria en un determinado entorno.  <a href="class_variable_neighborhood_search.html#a05f4646dcde00cb2efd2f41c34b40465">More...</a><br /></td></tr>
<tr class="separator:a05f4646dcde00cb2efd2f41c34b40465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90362e88ab783f076b3da025bac0014"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#ae90362e88ab783f076b3da025bac0014">constructSolution</a> (std::vector&lt; int &gt; candidates, int size)</td></tr>
<tr class="memdesc:ae90362e88ab783f076b3da025bac0014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Se encarga de construir la solución, para ello se ha generado un número aleatorio entre el número total de nodos y luego hace tantas iteraciones como de grande sea ese elemento, cogiendo el valor del entorno y cogiendo un elemento del mismo.  <a href="class_variable_neighborhood_search.html#ae90362e88ab783f076b3da025bac0014">More...</a><br /></td></tr>
<tr class="separator:ae90362e88ab783f076b3da025bac0014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab550c3635409191558d7cc2c9ae8a8b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_variable_neighborhood_search.html#ab550c3635409191558d7cc2c9ae8a8b9">greedyLocalSearch</a> (std::vector&lt; int &gt; solution, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:ab550c3635409191558d7cc2c9ae8a8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representa la búsqueda local greedy.  <a href="class_variable_neighborhood_search.html#ab550c3635409191558d7cc2c9ae8a8b9">More...</a><br /></td></tr>
<tr class="separator:ab550c3635409191558d7cc2c9ae8a8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_algorithm"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_algorithm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_algorithm.html">Algorithm</a></td></tr>
<tr class="memitem:a675939191b1136107cd43634d6c9df18 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a675939191b1136107cd43634d6c9df18">getMedianDispersion</a> (std::vector&lt; int &gt; solution, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:a675939191b1136107cd43634d6c9df18 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Este método se encarga de determinar la dispersión media, que se define por: Σi,j∈S d(i,j)  <a href="class_algorithm.html#a675939191b1136107cd43634d6c9df18">More...</a><br /></td></tr>
<tr class="separator:a675939191b1136107cd43634d6c9df18 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab695aa19342c5cc63685e98de5a828ac inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#ab695aa19342c5cc63685e98de5a828ac">getWorstMediaDispersion</a> (std::vector&lt; int &gt; actualSolution, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:ab695aa19342c5cc63685e98de5a828ac inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion se va a encargar de devolver el valor peor de la dispersión media, además en caso de que el tamaño del vector sea nulo, devuelve un valor -1, que será el que usemos apra gestionar ese caso.  <a href="class_algorithm.html#ab695aa19342c5cc63685e98de5a828ac">More...</a><br /></td></tr>
<tr class="separator:ab695aa19342c5cc63685e98de5a828ac inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9eff334377933946a3fb2e6ae638be inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top"><a id="a1e9eff334377933946a3fb2e6ae638be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printSolution</b> (std::vector&lt; int &gt; solution, int runTime, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="separator:a1e9eff334377933946a3fb2e6ae638be inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Esta clase representa el algoritmo multiarranque. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c246a6b89a9eea5f3b17352f7cc7178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c246a6b89a9eea5f3b17352f7cc7178">&#9670;&nbsp;</a></span>VariableNeighborhoodSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VariableNeighborhoodSearch::VariableNeighborhoodSearch </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newIterationsLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newnoImprovementIterationLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newKmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crea el objeto y le asigna un nombre del algoritmo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newName</td><td>Nuevo nombre del algoritmo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae90362e88ab783f076b3da025bac0014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90362e88ab783f076b3da025bac0014">&#9670;&nbsp;</a></span>constructSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; VariableNeighborhoodSearch::constructSolution </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Se encarga de construir la solución, para ello se ha generado un número aleatorio entre el número total de nodos y luego hace tantas iteraciones como de grande sea ese elemento, cogiendo el valor del entorno y cogiendo un elemento del mismo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidates</td><td>Vector del que se parte para construir la solución </td></tr>
    <tr><td class="paramname">size</td><td>Tamaño del entorno </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector &lt;int&gt; Vector con la solución construida </dd></dl>

</div>
</div>
<a id="aa545a238609462a4e45120dbc7c10cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa545a238609462a4e45120dbc7c10cde">&#9670;&nbsp;</a></span>getAlgorithmName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string VariableNeighborhoodSearch::getAlgorithmName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve el nombre del algoritmo. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string nombre del algoritmo </dd></dl>

</div>
</div>
<a id="af731669d721090aec1cdb79c4f8da891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af731669d721090aec1cdb79c4f8da891">&#9670;&nbsp;</a></span>getIterationsLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VariableNeighborhoodSearch::getIterationsLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve el límite de iteraciones. </p>
<dl class="section return"><dt>Returns</dt><dd>int Valor del límite de iteraciones </dd></dl>

</div>
</div>
<a id="aa6daf77e6bafdd0991a07ba116f2a788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6daf77e6bafdd0991a07ba116f2a788">&#9670;&nbsp;</a></span>getKmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VariableNeighborhoodSearch::getKmax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devvuelve el tamaño del entorno máximo. </p>
<dl class="section return"><dt>Returns</dt><dd>int Valor del entorno máximo </dd></dl>

</div>
</div>
<a id="a2a9260611826afa9fc98e533f4e14fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9260611826afa9fc98e533f4e14fcd">&#9670;&nbsp;</a></span>getnoImprovementiterationsLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VariableNeighborhoodSearch::getnoImprovementiterationsLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el número de iteracions sin mejora. </p>
<dl class="section return"><dt>Returns</dt><dd>int Devuelve el valor de las iteraciones sin mejora </dd></dl>

</div>
</div>
<a id="ab550c3635409191558d7cc2c9ae8a8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab550c3635409191558d7cc2c9ae8a8b9">&#9670;&nbsp;</a></span>greedyLocalSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; VariableNeighborhoodSearch::greedyLocalSearch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>currentGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Representa la búsqueda local greedy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>Representa el vector sobre el que vamos a generar la búsqueda local </td></tr>
    <tr><td class="paramname">currentGraph</td><td>Grafo con la información de las distacias entre nodos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector &lt;int&gt; Valor del vector </dd></dl>

</div>
</div>
<a id="a9801bff3a36806d818d300010e0cd529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9801bff3a36806d818d300010e0cd529">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_solution.html">Solution</a> VariableNeighborhoodSearch::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>currentGraph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Representa el método que va a realizar la ejecución del algorimo GVNS, para ello se va a partir de un conjunto de candidatos, que va a ser todo el conjunto de nodos. Una vez que tenemos esto, vamos a iterar hasta llegar a las iteraciones con o sin mejora, en cada una de ellas habrán iteraciones hasta que se llegue al tamaño de entorno máximo. En cada una de ellas se hará shake, luego se hará una búsqueda local y por último se buscará si la nueva solución tiene una dispersion media mejor que las anteriores y se asignará. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentGraph</td><td>Representa las distancias entre los nodos del grafo </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_solution.html" title="Representa una solucion, que va a contener el vector donde se almacena la misma , la media y luego el...">Solution</a> Solución al aplicar el GVNS </dd></dl>

<p>Implements <a class="el" href="class_algorithm.html#af16e663628d3e98d251acc53798bd299">Algorithm</a>.</p>

</div>
</div>
<a id="a05f4646dcde00cb2efd2f41c34b40465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f4646dcde00cb2efd2f41c34b40465">&#9670;&nbsp;</a></span>shake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; VariableNeighborhoodSearch::shake </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta es la función encargada de coger una solución aleatoria en un determinado entorno. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidates</td><td>Representa el vector de candidatos </td></tr>
    <tr><td class="paramname">currentK</td><td>Representa el valor actual de la variable de entorno </td></tr>
    <tr><td class="paramname">newSolution</td><td>Represenyta el valor del valor de la solucion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector &lt;int&gt; Vector con la nueva solucion construida </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/carlo/Desktop/DAA/DAA_P8/include/<a class="el" href="variable-neighborhood-search-algorithm_8hpp_source.html">variable-neighborhood-search-algorithm.hpp</a></li>
<li>variable-neighborhood-search-algorithm.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
