<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Max-mean dispersion problem: MultibootAlgorithm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Max-mean dispersion problem
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_multiboot_algorithm-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultibootAlgorithm Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Esta clase representa el algoritmo multiarranque.  
 <a href="class_multiboot_algorithm.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="multiboot-algorithm_8hpp_source.html">multiboot-algorithm.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MultibootAlgorithm:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm__inherit__graph.png" border="0" usemap="#_multiboot_algorithm_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MultibootAlgorithm:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm__coll__graph.png" border="0" usemap="#_multiboot_algorithm_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8812a5210c5cecac1c1f545bdd99df78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#a8812a5210c5cecac1c1f545bdd99df78">MultibootAlgorithm</a> (int currentLocalSearch, std::string newName, int newIterationsLimit, int noImprovementiterationsLimit)</td></tr>
<tr class="memdesc:a8812a5210c5cecac1c1f545bdd99df78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea el objeto y le asigna un nombre del algoritmo, además de la búsqueda local seleccionada, el número de iteraciones con y sin mejora.  <a href="class_multiboot_algorithm.html#a8812a5210c5cecac1c1f545bdd99df78">More...</a><br /></td></tr>
<tr class="separator:a8812a5210c5cecac1c1f545bdd99df78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66869b040b9e6994cc914187b4fb832b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#a66869b040b9e6994cc914187b4fb832b">getAlgorithmName</a> ()</td></tr>
<tr class="memdesc:a66869b040b9e6994cc914187b4fb832b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el nombre del algoritmo.  <a href="class_multiboot_algorithm.html#a66869b040b9e6994cc914187b4fb832b">More...</a><br /></td></tr>
<tr class="separator:a66869b040b9e6994cc914187b4fb832b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684e8d63d274d71c9e76a39b80db2b70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#a684e8d63d274d71c9e76a39b80db2b70">getIterationsLimit</a> ()</td></tr>
<tr class="memdesc:a684e8d63d274d71c9e76a39b80db2b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el límite de iteraciones.  <a href="class_multiboot_algorithm.html#a684e8d63d274d71c9e76a39b80db2b70">More...</a><br /></td></tr>
<tr class="separator:a684e8d63d274d71c9e76a39b80db2b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dadef0ec3df41b0cf791cb181240a83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#a5dadef0ec3df41b0cf791cb181240a83">getnoImprovementiterationsLimit</a> ()</td></tr>
<tr class="memdesc:a5dadef0ec3df41b0cf791cb181240a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el número de iteracions sin mejora.  <a href="class_multiboot_algorithm.html#a5dadef0ec3df41b0cf791cb181240a83">More...</a><br /></td></tr>
<tr class="separator:a5dadef0ec3df41b0cf791cb181240a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a958037ce7775775f47f9ffb01a9dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#a02a958037ce7775775f47f9ffb01a9dc">getChoosenLocalSearch</a> ()</td></tr>
<tr class="memdesc:a02a958037ce7775775f47f9ffb01a9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la búsqueda local que se ha seleccionado.  <a href="class_multiboot_algorithm.html#a02a958037ce7775775f47f9ffb01a9dc">More...</a><br /></td></tr>
<tr class="separator:a02a958037ce7775775f47f9ffb01a9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80ce488f75d97a6a208be3f6c94d08a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#aa80ce488f75d97a6a208be3f6c94d08a">run</a> (<a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:aa80ce488f75d97a6a208be3f6c94d08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Este método se encarga de ejecutar el algoritmo multiarranque, para ello se hace un preprocesamiento, teniendo un conjunto de candidatos. Una vez esto, se definen como condiciones de parada las iteraciones con y sin mejora, y luego en cada iteración se va construyendo la solución, se hace la búsqueda local (greedy) y se asigna al máximo la solución que tenga mayor dispersión media.  <a href="class_multiboot_algorithm.html#aa80ce488f75d97a6a208be3f6c94d08a">More...</a><br /></td></tr>
<tr class="separator:aa80ce488f75d97a6a208be3f6c94d08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcea30f3f236079b0f40e88e624e19a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#a3bcea30f3f236079b0f40e88e624e19a">preprocessing</a> (<a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:a3bcea30f3f236079b0f40e88e624e19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion se encarga de hacer el preprocesamiento, para ello, va a escoger los nodos cuyas aristas (todas), sean no negativas, es decir, mayores o iguales a 0.  <a href="class_multiboot_algorithm.html#a3bcea30f3f236079b0f40e88e624e19a">More...</a><br /></td></tr>
<tr class="separator:a3bcea30f3f236079b0f40e88e624e19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49462e8dc4630e383aa8e1db106c087e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#a49462e8dc4630e383aa8e1db106c087e">constructSolution</a> (std::vector&lt; int &gt; solution, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:a49462e8dc4630e383aa8e1db106c087e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Se encarga de construir la solución, para ello se ha generado un número aleatorio entre el número total de nodos y luego hace tantas iteraciones como de grande sea ese elemento, luego se asigna a un elemento una posición aleatoria del vector de candidatos, y en caso que ese elemento en el array no esté en la solución, pues se añade en la misma.  <a href="class_multiboot_algorithm.html#a49462e8dc4630e383aa8e1db106c087e">More...</a><br /></td></tr>
<tr class="separator:a49462e8dc4630e383aa8e1db106c087e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d286b059b5752f0da963e0ece89204e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_multiboot_algorithm.html#a2d286b059b5752f0da963e0ece89204e">localSearch</a> (std::vector&lt; int &gt; solution, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:a2d286b059b5752f0da963e0ece89204e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representa la búsqueda local greedy.  <a href="class_multiboot_algorithm.html#a2d286b059b5752f0da963e0ece89204e">More...</a><br /></td></tr>
<tr class="separator:a2d286b059b5752f0da963e0ece89204e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596f70362450576463ecb31aebdf9fd5"><td class="memItemLeft" align="right" valign="top"><a id="a596f70362450576463ecb31aebdf9fd5"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>notSelectedNodes</b> (std::vector&lt; int &gt; checkSelected, int nodeNumber)</td></tr>
<tr class="separator:a596f70362450576463ecb31aebdf9fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_algorithm"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_algorithm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_algorithm.html">Algorithm</a></td></tr>
<tr class="memitem:a675939191b1136107cd43634d6c9df18 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a675939191b1136107cd43634d6c9df18">getMedianDispersion</a> (std::vector&lt; int &gt; solution, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:a675939191b1136107cd43634d6c9df18 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Este método se encarga de determinar la dispersión media, que se define por: Σi,j∈S d(i,j)  <a href="class_algorithm.html#a675939191b1136107cd43634d6c9df18">More...</a><br /></td></tr>
<tr class="separator:a675939191b1136107cd43634d6c9df18 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94433d3be0e1f212f4fb5ea6a360d528 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a94433d3be0e1f212f4fb5ea6a360d528">getWorstMediaDispersionGreedy</a> (std::vector&lt; int &gt; actualSolution, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:a94433d3be0e1f212f4fb5ea6a360d528 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion se va a encargar de devolver el valor peor de la dispersión media, se aplica de forma greedy además en caso de que el tamaño del vector sea nulo, devuelve un valor -1, que será el que usemos apra gestionar ese caso.  <a href="class_algorithm.html#a94433d3be0e1f212f4fb5ea6a360d528">More...</a><br /></td></tr>
<tr class="separator:a94433d3be0e1f212f4fb5ea6a360d528 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba2b3302571277bac3eeb1070cf3cb2 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a9ba2b3302571277bac3eeb1070cf3cb2">getWorstMediaDispersionAnxious</a> (std::vector&lt; int &gt; actualSolution, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="memdesc:a9ba2b3302571277bac3eeb1070cf3cb2 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion se va a encargar de devolver el valor peor de la dispersión media, se aplica de forma ansiosa, es decir, desde que se encuentre alguno mejor se va a devolver. En caso de que el vector esté vacío o no haya ninguno mejor se va a retornar un -1.  <a href="class_algorithm.html#a9ba2b3302571277bac3eeb1070cf3cb2">More...</a><br /></td></tr>
<tr class="separator:a9ba2b3302571277bac3eeb1070cf3cb2 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9eff334377933946a3fb2e6ae638be inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top"><a id="a1e9eff334377933946a3fb2e6ae638be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printSolution</b> (std::vector&lt; int &gt; solution, int runTime, <a class="el" href="class_graph.html">Graph</a> currentGraph)</td></tr>
<tr class="separator:a1e9eff334377933946a3fb2e6ae638be inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Esta clase representa el algoritmo multiarranque. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8812a5210c5cecac1c1f545bdd99df78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8812a5210c5cecac1c1f545bdd99df78">&#9670;&nbsp;</a></span>MultibootAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MultibootAlgorithm::MultibootAlgorithm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentLocalSearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newIterationsLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newnoImprovementIterationLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crea el objeto y le asigna un nombre del algoritmo, además de la búsqueda local seleccionada, el número de iteraciones con y sin mejora. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newName</td><td>Nuevo nombre del algoritmo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a49462e8dc4630e383aa8e1db106c087e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49462e8dc4630e383aa8e1db106c087e">&#9670;&nbsp;</a></span>constructSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; MultibootAlgorithm::constructSolution </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>currentGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Se encarga de construir la solución, para ello se ha generado un número aleatorio entre el número total de nodos y luego hace tantas iteraciones como de grande sea ese elemento, luego se asigna a un elemento una posición aleatoria del vector de candidatos, y en caso que ese elemento en el array no esté en la solución, pues se añade en la misma. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentSolution</td><td>Vector del que se parte para construir la solución </td></tr>
    <tr><td class="paramname">totalNodes</td><td>Numero total de nodos del grafo </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector &lt;int&gt; Vector con la solución construida </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a49462e8dc4630e383aa8e1db106c087e_icgraph.png" border="0" usemap="#class_multiboot_algorithm_a49462e8dc4630e383aa8e1db106c087e_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a66869b040b9e6994cc914187b4fb832b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66869b040b9e6994cc914187b4fb832b">&#9670;&nbsp;</a></span>getAlgorithmName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string MultibootAlgorithm::getAlgorithmName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve el nombre del algoritmo. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string nombre del algoritmo </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a66869b040b9e6994cc914187b4fb832b_icgraph.png" border="0" usemap="#class_multiboot_algorithm_a66869b040b9e6994cc914187b4fb832b_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a02a958037ce7775775f47f9ffb01a9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a958037ce7775775f47f9ffb01a9dc">&#9670;&nbsp;</a></span>getChoosenLocalSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MultibootAlgorithm::getChoosenLocalSearch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve la búsqueda local que se ha seleccionado. </p>
<dl class="section return"><dt>Returns</dt><dd>int Valor de la búsqueda local seleccionda, en caso de que sea 0 es ansiosa y 1 es greedy. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a02a958037ce7775775f47f9ffb01a9dc_icgraph.png" border="0" usemap="#class_multiboot_algorithm_a02a958037ce7775775f47f9ffb01a9dc_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a684e8d63d274d71c9e76a39b80db2b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684e8d63d274d71c9e76a39b80db2b70">&#9670;&nbsp;</a></span>getIterationsLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MultibootAlgorithm::getIterationsLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve el límite de iteraciones. </p>
<dl class="section return"><dt>Returns</dt><dd>int Valor del límite de iteraciones </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a684e8d63d274d71c9e76a39b80db2b70_icgraph.png" border="0" usemap="#class_multiboot_algorithm_a684e8d63d274d71c9e76a39b80db2b70_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a5dadef0ec3df41b0cf791cb181240a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dadef0ec3df41b0cf791cb181240a83">&#9670;&nbsp;</a></span>getnoImprovementiterationsLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MultibootAlgorithm::getnoImprovementiterationsLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el número de iteracions sin mejora. </p>
<dl class="section return"><dt>Returns</dt><dd>int Devuelve el valor de las iteraciones sin mejora </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a5dadef0ec3df41b0cf791cb181240a83_icgraph.png" border="0" usemap="#class_multiboot_algorithm_a5dadef0ec3df41b0cf791cb181240a83_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a2d286b059b5752f0da963e0ece89204e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d286b059b5752f0da963e0ece89204e">&#9670;&nbsp;</a></span>localSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; MultibootAlgorithm::localSearch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>currentGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Representa la búsqueda local greedy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>Representa el vector sobre el que vamos a generar la búsqueda local </td></tr>
    <tr><td class="paramname">currentGraph</td><td>Grafo con la información de las distacias entre nodos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector &lt;int&gt; Valor del vector </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a2d286b059b5752f0da963e0ece89204e_cgraph.png" border="0" usemap="#class_multiboot_algorithm_a2d286b059b5752f0da963e0ece89204e_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a2d286b059b5752f0da963e0ece89204e_icgraph.png" border="0" usemap="#class_multiboot_algorithm_a2d286b059b5752f0da963e0ece89204e_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a3bcea30f3f236079b0f40e88e624e19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcea30f3f236079b0f40e88e624e19a">&#9670;&nbsp;</a></span>preprocessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; MultibootAlgorithm::preprocessing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>currentGraph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion se encarga de hacer el preprocesamiento, para ello, va a escoger los nodos cuyas aristas (todas), sean no negativas, es decir, mayores o iguales a 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentGraph</td><td>Representa el grafo con las distancias entre los nodos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector &lt;int&gt; Representa un vector con el resultado del preprocesamiento </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a3bcea30f3f236079b0f40e88e624e19a_cgraph.png" border="0" usemap="#class_multiboot_algorithm_a3bcea30f3f236079b0f40e88e624e19a_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_a3bcea30f3f236079b0f40e88e624e19a_icgraph.png" border="0" usemap="#class_multiboot_algorithm_a3bcea30f3f236079b0f40e88e624e19a_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aa80ce488f75d97a6a208be3f6c94d08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80ce488f75d97a6a208be3f6c94d08a">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_solution.html">Solution</a> MultibootAlgorithm::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>currentGraph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Este método se encarga de ejecutar el algoritmo multiarranque, para ello se hace un preprocesamiento, teniendo un conjunto de candidatos. Una vez esto, se definen como condiciones de parada las iteraciones con y sin mejora, y luego en cada iteración se va construyendo la solución, se hace la búsqueda local (greedy) y se asigna al máximo la solución que tenga mayor dispersión media. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentGraph</td><td>Representa el grafo con las distancias entre nodos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_solution.html" title="Representa una solucion, que va a contener el vector donde se almacena la misma , la media y luego el...">Solution</a> Solucion del problema </dd></dl>

<p>Implements <a class="el" href="class_algorithm.html#af16e663628d3e98d251acc53798bd299">Algorithm</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_multiboot_algorithm_aa80ce488f75d97a6a208be3f6c94d08a_cgraph.png" border="0" usemap="#class_multiboot_algorithm_aa80ce488f75d97a6a208be3f6c94d08a_cgraph" alt=""/></div>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="multiboot-algorithm_8hpp_source.html">multiboot-algorithm.hpp</a></li>
<li>src/multiboot-algorithm.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
